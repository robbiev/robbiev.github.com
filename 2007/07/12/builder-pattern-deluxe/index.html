<!DOCTYPE html><html><head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Builder Pattern Deluxe</title>
    <link rel="stylesheet" type="text/css" href="/style.css"/>
    <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml"/>
  </head>
  <body>
    <div class="body">
      <div class="header">
        <div class="title">
          <a href="/">Robbie&#39;s Garbage, Collected.</a>
        </div>
        <input type="checkbox" id="theme-toggle" aria-label="Toggle theme"/>
        <label for="theme-toggle" class="theme-toggle-label"></label>
      </div>
      <div class="blog">
        <h1>Builder Pattern Deluxe</h1>
        <div class="date">July 12, 2007</div>
        <div class="entry">

        <p><strong>Update:</strong> code available at <a href="http://code.google.com/p/garbagecollected/">http://code.google.com/p/garbagecollected/</a></p>
<p>Yesterday evening I came up with an interesting approach for implementing <a href="http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-2689.pdf">Josh Bloch&#39;s revised GoF Builder pattern</a> (warning: PDF). After some late night hacking, I can&#39;t help but feel that this is very useful stuff. Take a look at Josh&#39;s presentation first, and then take a look at this:</p>
<pre><code>package builder;

public class SomeObject {
  private final String mandatory;
  private final int optional1;
  private final char optional2;

  private SomeObject (SomeObjectBuilder builder, String mandatory) {
    this.mandatory = mandatory;
    this.optional1 = builder.optional1();
    this.optional2 = builder.optional2();
  }

  public interface SomeObjectBuilder extends Builder {
    SomeObjectBuilder optional1(int optional1);
    SomeObjectBuilder optional2(char optional2);
    int optional1();
    char optional2();
  }

  public static SomeObjectBuilder builder (final String mandatory) {
    return BuilderFactory.make (SomeObjectBuilder.class,
        new BuilderCallback () {
          public SomeObject call (SomeObjectBuilder builder) throws Exception {
            return new SomeObject(builder, mandatory);
          }
    });
  }

  public String toString() {
    return new StringBuilder()
      .append (getClass().getName())
      .append (String.format (&#34;[optional1=%s, &#34;, optional1))
      .append (String.format (&#34;optional2=%s, &#34;, optional2))
      .append (String.format (&#34;mandatory=%s]&#34;, mandatory)).toString();
  }

  public static void main(String[] args) {
    System.out.println(SomeObject.builder(&#34;Mandatory!&#34;)
        .optional1(35)
        .optional2(&#39;A&#39;)
        .build()
        .toString()
    );
  }
}
</code></pre>
<p>Console output: <code>SomeObject[optional1=35, optional2=A, mandatory=Mandatory!]</code></p>
<p>Using a dynamic proxy, the <code>BuilderFactory</code> provides the <code>Builder&lt;T&gt;</code> implementation for a given interface, so that you don&#39;t have to write all that horrible boilerplate code. Often you use a builder when constructors get messy, but Builders with many parameters get messy too. Using this approach you not only save time, you also have the advantage of using a static factory method and having your specific builder as an interface instead of a concrete class. Full source code available upon request; feedback/suggestions/improvements appreciated!</p>
<p>Eat that, setter injection ;-)</p>
</div>
        <div class="footer">
          <em>Liking this? Follow me: <a href="/rss.xml">RSS</a>, <a href="https://bsky.app/profile/robbiev.uk">Bluesky</a>, <a href="https://mastodon.social/@robbiev">Mastodon</a>.</em>
        </div>
      </div>
    </div>
  

</body></html>