<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Scripting Guice</title>
    <link rel="stylesheet" type="text/css" href="/style.css">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38858050-1']);
      _gaq.push(['_trackPageview']);
      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();
    </script>
  </head>
  <body>
    <div class="body">
      <div class="header">
        <div class="title">
          <a href="/">Robbie&apos;s Garbage, Collected.</a>
        </div>
      </div>
      <div class="blog">
        <h1>Scripting Guice</h1>
        <div class="date">May 6, 2007</div>
        <div class="entry">I really like <a href="http://code.google.com/p/google-guice/" title="Google Guice" target="_blank">Guice</a>, a Java 5 style Dependency Injection framework by the bright guys at Google.<br><br>People who are used to <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-metadata" target="_blank">Spring&apos;s DI config</a> often complain that they don&apos;t like the &quot;compiled configuration&quot; thing (Java Modules) Guice has. In Spring, all your wiring is usually done in XML. So on one side you have compiled Java Guice Modules, a more natural programming model for Java developers, and on the other side you have XML configuration, nicely externalized.  And yes, I know the Spring guys plan on having a Java version of their configuration syntax, but it looks just like the XML, so I don&apos;t see any real advantages there.<br><br>Anyway, for the Spring users who want to try out Guice, you could externalize your configuration to a properties file, and load it from that. Or whatever format you&apos;re willing to use. Heck, you could even write some code that parses a Spring config file and translates it into a Guice Module.<br><br>But here&apos;s another idea: what about using a scripting language for all your object wiring needs? Why create a configuration file if you could use the highly readable Guice Binder syntax? Well, I tried it, and it  works great :-)<br><br>Let&apos;s start with an example. This one&apos;s about me drinking some beer. So here&apos;s me:<br><pre><br>public class Robbie {<br>    private Beer myBeer;<br><br>    @Inject<br>    public Robbie(@Strong Beer freshBeer) {<br>        this.myBeer = freshBeer;<br>    }<br>    public void startDrinking() {<br>        myBeer.drink();<br>    }<br>}</pre><br>And here&apos;s some beer:<br><pre><br>public interface Beer {<br>    void drink();<br>}<br>public class Duvel implements Beer {<br>    public void drink() {<br>        System.out.println(&quot;Duvel!&quot;);<br>    }<br>}<br>public class StellaArtois implements Beer {<br>    public void drink() {<br>        System.out.println(&quot;Stella Artois&quot;);<br>    }<br>}</pre><br>The <code>@Strong</code> annotation basically means I&apos;d like a strong beer, not just some water with taste. So I created a Guice <code>BindingAnnotation</code> for that, and expressed the binding in a module:<br><pre><br>@Retention(RetentionPolicy.RUNTIME)<br>@Target({ElementType.FIELD, ElementType.PARAMETER})<br>@BindingAnnotation<br>public @interface Strong {}</pre><br><pre><br>public class BeerModule implements Module {<br>    public void configure(Binder binder) {<br>        binder.bind(Beer.class).to(StellaArtois.class);<br>        binder.bind(Beer.class).annotatedWith(Strong.class).to(Duvel.class);<br>        System.out.println(&quot;Configured using Java implemented Guice Module!&quot;);<br>    }<br>}</pre><br>So everyone is getting regular beers, unless they specify they want some stronger beer. You could run this code like this:<br><pre><br>public class StartGuice {<br>    public static void main(String[] args) {<br>        Injector i = Guice.createInjector(Stage.DEVELOPMENT, new BeerModule());<br>        Robbie robbie = i.getInstance(Robbie.class);<br>        System.out.print(&quot;Robbie starts drinking: &quot;);<br>        robbie.startDrinking();<br>    }<br>}</pre><br>This prints:<br><pre><br>    Configured using Java implemented Guice Module!<br>    Robbie starts drinking: Duvel!</pre><br>Hmm... tasty. Now, let&apos;s get us some scripting. I&apos;ll thankfully use the new <a href="https://scripting.dev.java.net/" target="_blank">Java 6 scripting support</a>, you could probably use the <a href="http://jakarta.apache.org/bsf/" title="Bean Scripting Framework" target="_blank">BSF</a> as well. Also, I&apos;ll use <a href="http://www.jython.org" target="_blank">Jython</a> for scripting, a Java Python implementation. So I throw in <code>jython.jar</code>, <code>jython-engine.jar</code> (from the scripting site), <code>aopalliance.jar</code> next to the <code>guice.jar</code>. By the way, if you want to know how all this scripting support stuff works, check out <a href="http://jroller.com/page/mom?entry=tutorial_running_ruby_using_the" target="_blank">Jurgen&apos;s excellent introduction</a>.<br><br>Anyway, let&apos;s try binding our dependencies in Python. Create a file called <code>BeerBinder.py</code> that looks like this:<br><pre><br>import java<br>from scriptguice import *<br><br>    def configure(binder):<br>        binder.bind(Beer).to(StellaArtois);<br>        binder.bind(Beer).annotatedWith(Strong).to(Duvel);<br>        print &quot;Configured Guice using Python method!&quot;</pre><br>Then we add some scripting magic to our Guice Module, so that we delegate the configure call to the Python script:<br><pre><br>public class BeerModule implements Module {<br>    public void configure(Binder binder) {<br>        ScriptEngineManager mgr = new ScriptEngineManager();<br>        ScriptEngine python = mgr.getEngineByName(&quot;python&quot;);<br>        Reader reader = ReadUtil.getReaderForClassPathResource(&quot;scriptguice/pythonmethod/BeerBinder.py&quot;);<br>        try {<br>            python.eval(reader);<br>            Invocable invocablePython = (Invocable) python;<br>            invocablePython.invokeFunction(&quot;configure&quot;, binder);<br>        } catch (ScriptException e) {<br>            throw new RuntimeException(e);<br>        } catch (NoSuchMethodException e) {<br>            throw new RuntimeException(e);<br>        }<br>    }<br>}</pre><br>If we run <code>StartGuice</code> again, the output now looks like:<br><pre><br>    Configured Guice using Python method!<br>    Robbie starts drinking: Duvel!</pre><br>Great, it works! Now let&apos;s take it one step further and get rid of the ugly Java / Python mix. Python all the way! Create a file called <code>BeerModule.py</code>:<br><pre><br>import java<br>from scriptguice import *<br>from com.google.inject import *<br><br>class BeerModule(Module):<br>    def configure(self, binder):<br>        binder.bind(Beer).to(StellaArtois);<br>        binder.bind(Beer).annotatedWith(Strong).to(Duvel);<br>        print &quot;Configured using Python implemented Guice Module!&quot;<br><br># Factory method that returns new BeerModule<br>def getBeerModule():<br>    return BeerModule()</pre><br>So we created a class called <code>BeerModule</code>, and subclassed the Java class <code>com.google.inject.Module</code>. Jython really starts to shine here. Let&apos;s do some magic to get the thing back in Java:<br><pre><br>public class StartGuice {<br>    public static Module getPythonBeerModule() {<br>        ScriptEngineManager mgr = new ScriptEngineManager();<br>        ScriptEngine python = mgr.getEngineByName(&quot;python&quot;);<br>        try {<br>            Reader reader = ReadUtil.getReaderForClassPathResource(&quot;scriptguice/pythonclass/BeerModule.py&quot;);<br>            python.eval(reader);<br>            Invocable invocablePython = (Invocable)python;<br>            return (Module)invocablePython.invokeFunction(&quot;getBeerModule&quot;);<br>        } catch (ScriptException e) {<br>            throw new RuntimeException(e);<br>        } catch (NoSuchMethodException e) {<br>            throw new RuntimeException(e);<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        Injector i = Guice.createInjector(Stage.DEVELOPMENT, getPythonBeerModule());<br>        Robbie robbie = i.getInstance(Robbie.class);<br>        System.out.print(&quot;Robbie starts drinking: &quot;);<br>        robbie.startDrinking();<br>    }<br>}</pre><br>It&apos;s been a long time since my last beer, so here we go:<br><pre><br>    Configured using Python implemented Guice Module!<br>    Robbie starts drinking: Duvel!</pre><br>Man, how cool is this? Now we have defined the entire Guice module in Python code, and I got drunk in the process. Life just doesn&apos;t get any better, does it ;-)<br><br>Now you could take it even further and return an array of Modules or what not, which is probably what you want in a real world app. Oh and one final note: don&apos;t just copy paste this code. Close the Reader and stuff. I&apos;m just being lazy for the sake of the example.<br><br>Thanks to <a href="http://crazybob.org/" target="_blank">Bob Lee</a> and <a href="http://smallwig.blogspot.com/">Kevin Bourrillion</a> for creating Guice, the coolest DI framework on the planet.</div>
        <div class="footer">
          <em>Liking this? Follow me <a href="https://twitter.com/robbiev">on Twitter</a>.</em>
        </div>
      </div>
    </div>
  </body>
</html>
