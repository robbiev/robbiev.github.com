<!DOCTYPE html><html><head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Scripting Guice</title>
    <link rel="stylesheet" type="text/css" href="/style.css"/>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38858050-1']);
      _gaq.push(['_trackPageview']);
      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();
    </script>
  </head>
  <body>
    <div class="body">
      <div class="header">
        <div class="title">
          <a href="/">Robbie&#39;s Garbage, Collected.</a>
        </div>
      </div>
      <div class="blog">
        <h1>Scripting Guice</h1>
        <div class="date">May 6, 2007</div>
        <div class="entry">

        I really like <a href="http://code.google.com/p/google-guice/" title="Google Guice" target="_blank">Guice</a>, a Java 5 style Dependency Injection framework by the bright guys at Google.<br/><br/>People who are used to <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-metadata" target="_blank">Spring&#39;s DI config</a> often complain that they don&#39;t like the &#34;compiled configuration&#34; thing (Java Modules) Guice has. In Spring, all your wiring is usually done in XML. So on one side you have compiled Java Guice Modules, a more natural programming model for Java developers, and on the other side you have XML configuration, nicely externalized.  And yes, I know the Spring guys plan on having a Java version of their configuration syntax, but it looks just like the XML, so I don&#39;t see any real advantages there.<br/><br/>Anyway, for the Spring users who want to try out Guice, you could externalize your configuration to a properties file, and load it from that. Or whatever format you&#39;re willing to use. Heck, you could even write some code that parses a Spring config file and translates it into a Guice Module.<br/><br/>But here&#39;s another idea: what about using a scripting language for all your object wiring needs? Why create a configuration file if you could use the highly readable Guice Binder syntax? Well, I tried it, and it  works great :-)<br/><br/>Let&#39;s start with an example. This one&#39;s about me drinking some beer. So here&#39;s me:<br/><pre><br/>public class Robbie {<br/>    private Beer myBeer;<br/><br/>    @Inject<br/>    public Robbie(@Strong Beer freshBeer) {<br/>        this.myBeer = freshBeer;<br/>    }<br/>    public void startDrinking() {<br/>        myBeer.drink();<br/>    }<br/>}</pre><br/>And here&#39;s some beer:<br/><pre><br/>public interface Beer {<br/>    void drink();<br/>}<br/>public class Duvel implements Beer {<br/>    public void drink() {<br/>        System.out.println(&#34;Duvel!&#34;);<br/>    }<br/>}<br/>public class StellaArtois implements Beer {<br/>    public void drink() {<br/>        System.out.println(&#34;Stella Artois&#34;);<br/>    }<br/>}</pre><br/>The <code>@Strong</code> annotation basically means I&#39;d like a strong beer, not just some water with taste. So I created a Guice <code>BindingAnnotation</code> for that, and expressed the binding in a module:<br/><pre><br/>@Retention(RetentionPolicy.RUNTIME)<br/>@Target({ElementType.FIELD, ElementType.PARAMETER})<br/>@BindingAnnotation<br/>public @interface Strong {}</pre><br/><pre><br/>public class BeerModule implements Module {<br/>    public void configure(Binder binder) {<br/>        binder.bind(Beer.class).to(StellaArtois.class);<br/>        binder.bind(Beer.class).annotatedWith(Strong.class).to(Duvel.class);<br/>        System.out.println(&#34;Configured using Java implemented Guice Module!&#34;);<br/>    }<br/>}</pre><br/>So everyone is getting regular beers, unless they specify they want some stronger beer. You could run this code like this:<br/><pre><br/>public class StartGuice {<br/>    public static void main(String[] args) {<br/>        Injector i = Guice.createInjector(Stage.DEVELOPMENT, new BeerModule());<br/>        Robbie robbie = i.getInstance(Robbie.class);<br/>        System.out.print(&#34;Robbie starts drinking: &#34;);<br/>        robbie.startDrinking();<br/>    }<br/>}</pre><br/>This prints:<br/><pre><br/>    Configured using Java implemented Guice Module!<br/>    Robbie starts drinking: Duvel!</pre><br/>Hmm... tasty. Now, let&#39;s get us some scripting. I&#39;ll thankfully use the new <a href="https://java.net/projects/scripting/" target="_blank">Java 6 scripting support</a>, you could probably use the <a href="http://jakarta.apache.org/bsf/" title="Bean Scripting Framework" target="_blank">BSF</a> as well. Also, I&#39;ll use <a href="http://www.jython.org" target="_blank">Jython</a> for scripting, a Java Python implementation. So I throw in <code>jython.jar</code>, <code>jython-engine.jar</code> (from the scripting site), <code>aopalliance.jar</code> next to the <code>guice.jar</code>. By the way, if you want to know how all this scripting support stuff works, check out <a href="http://jroller.com/page/mom?entry=tutorial_running_ruby_using_the" target="_blank">Jurgen&#39;s excellent introduction</a>.<br/><br/>Anyway, let&#39;s try binding our dependencies in Python. Create a file called <code>BeerBinder.py</code> that looks like this:<br/><pre><br/>import java<br/>from scriptguice import *<br/><br/>    def configure(binder):<br/>        binder.bind(Beer).to(StellaArtois);<br/>        binder.bind(Beer).annotatedWith(Strong).to(Duvel);<br/>        print &#34;Configured Guice using Python method!&#34;</pre><br/>Then we add some scripting magic to our Guice Module, so that we delegate the configure call to the Python script:<br/><pre><br/>public class BeerModule implements Module {<br/>    public void configure(Binder binder) {<br/>        ScriptEngineManager mgr = new ScriptEngineManager();<br/>        ScriptEngine python = mgr.getEngineByName(&#34;python&#34;);<br/>        Reader reader = ReadUtil.getReaderForClassPathResource(&#34;scriptguice/pythonmethod/BeerBinder.py&#34;);<br/>        try {<br/>            python.eval(reader);<br/>            Invocable invocablePython = (Invocable) python;<br/>            invocablePython.invokeFunction(&#34;configure&#34;, binder);<br/>        } catch (ScriptException e) {<br/>            throw new RuntimeException(e);<br/>        } catch (NoSuchMethodException e) {<br/>            throw new RuntimeException(e);<br/>        }<br/>    }<br/>}</pre><br/>If we run <code>StartGuice</code> again, the output now looks like:<br/><pre><br/>    Configured Guice using Python method!<br/>    Robbie starts drinking: Duvel!</pre><br/>Great, it works! Now let&#39;s take it one step further and get rid of the ugly Java / Python mix. Python all the way! Create a file called <code>BeerModule.py</code>:<br/><pre><br/>import java<br/>from scriptguice import *<br/>from com.google.inject import *<br/><br/>class BeerModule(Module):<br/>    def configure(self, binder):<br/>        binder.bind(Beer).to(StellaArtois);<br/>        binder.bind(Beer).annotatedWith(Strong).to(Duvel);<br/>        print &#34;Configured using Python implemented Guice Module!&#34;<br/><br/># Factory method that returns new BeerModule<br/>def getBeerModule():<br/>    return BeerModule()</pre><br/>So we created a class called <code>BeerModule</code>, and subclassed the Java class <code>com.google.inject.Module</code>. Jython really starts to shine here. Let&#39;s do some magic to get the thing back in Java:<br/><pre><br/>public class StartGuice {<br/>    public static Module getPythonBeerModule() {<br/>        ScriptEngineManager mgr = new ScriptEngineManager();<br/>        ScriptEngine python = mgr.getEngineByName(&#34;python&#34;);<br/>        try {<br/>            Reader reader = ReadUtil.getReaderForClassPathResource(&#34;scriptguice/pythonclass/BeerModule.py&#34;);<br/>            python.eval(reader);<br/>            Invocable invocablePython = (Invocable)python;<br/>            return (Module)invocablePython.invokeFunction(&#34;getBeerModule&#34;);<br/>        } catch (ScriptException e) {<br/>            throw new RuntimeException(e);<br/>        } catch (NoSuchMethodException e) {<br/>            throw new RuntimeException(e);<br/>        }<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        Injector i = Guice.createInjector(Stage.DEVELOPMENT, getPythonBeerModule());<br/>        Robbie robbie = i.getInstance(Robbie.class);<br/>        System.out.print(&#34;Robbie starts drinking: &#34;);<br/>        robbie.startDrinking();<br/>    }<br/>}</pre><br/>It&#39;s been a long time since my last beer, so here we go:<br/><pre><br/>    Configured using Python implemented Guice Module!<br/>    Robbie starts drinking: Duvel!</pre><br/>Man, how cool is this? Now we have defined the entire Guice module in Python code, and I got drunk in the process. Life just doesn&#39;t get any better, does it ;-)<br/><br/>Now you could take it even further and return an array of Modules or what not, which is probably what you want in a real world app. Oh and one final note: don&#39;t just copy paste this code. Close the Reader and stuff. I&#39;m just being lazy for the sake of the example.<br/><br/>Thanks to <a href="https://twitter.com/crazybob" target="_blank">Bob Lee</a> and <a href="http://smallwig.blogspot.com/">Kevin Bourrillion</a> for creating Guice, the coolest DI framework on the planet.
</div>
        <div class="footer">
          <em>Liking this? Follow me <a href="https://twitter.com/robbiev">on Twitter</a></em>
        </div>
      </div>
    </div>
  

</body></html>